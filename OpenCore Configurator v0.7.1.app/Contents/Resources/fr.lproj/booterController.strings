
/* Class = "NSButtonCell"; title = "DiscardHibernateMap"; ObjectID = "2QZ-Md-QHk"; */
"2QZ-Md-QHk.title" = "DiscardHibernateMap";

/* Class = "NSTableColumn"; headerCell.title = "Mask"; ObjectID = "3Ee-Qq-8wZ"; */
"3Ee-Qq-8wZ.headerCell.title" = "Mask";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI services from being overridden by the firmware.\n\nSome modernfirmware, including on virtual machines such as VMware, may update pointers to UEFI services during driver loading and related actions. Consequentially this directly breaks other quirks that affect memory management, such as DevirtualiseMmio, ProtectMemoryRegions, or RebuildAppleMemoryMap, and may also break other quirks depending on the effects of these.\n\nNote: On VMware the need for this quirk may be diagnosed by “Your Mac OS guest might run unreliably with more than one virtual core.” message."; ObjectID = "3fG-t6-MF7"; */
"3fG-t6-MF7.ibShadowedToolTip" = "Protégez les services UEFI contre l'écrasement par le micrologiciel. \nCertains micrologiciels modernes, y compris le matériel et les machines virtuelles (comme VMware), peuvent mettre à jour les pointeurs vers les services UEFI pendant le chargement du pilote et les opérations associées. Ainsi, cela détruit directement d'autres bizarreries qui affectent la gestion de la mémoire, telles que VirtualiseMmio, ProtectCsmRegion ou ShrinkMemoryMap, et peut également casser d'autres bizarreries, selon l'impact de ces bizarreries. \n \nRemarque: Sur VMware, vous pouvez diagnostiquer avec le message \"Votre invité Mac OS peut s'exécuter de manière non fiable avec plusieurs cœurs virtuels.\" Ce problème. \n \nZ390 est recommandé!";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect memory regions from incorrect access.\n\nSome types of firmware incorrectly map select memory regions:\n• CSM region can be marked as boot services code or data, which leaves it as free memory for XNU kernel. \n• MMIO regions can be marked as reserved memory and stay unmapped, but may be required to be accessible at runtime for NVRAM support.\n\nThis quirk attempts to fix types of these regions, e.g. ACPI NVS for CSM or MMIO for MMIO.\n\nNote: The necessity of this quirk is determined by artifacts, sleep wake issues, and boot failures. Only very old firmware typically need this quirk."; ObjectID = "5Km-5w-nkl"; */
"5Km-5w-nkl.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false \nDescription: Protégez les régions de mémoire contre les accès incorrects. \nCertains firmwares mappent incorrectement certaines régions de mémoire: \n • La région CSM peut être marquée comme code ou données de services de démarrage, ce qui la laisse comme mémoire libre pour XNU noyau. \n • Les régions MMIO peuvent être marquées en tant que mémoire réservée et rester non mappées, mais peuvent être requises pour être accessibles au moment de l'exécution pour la prise en charge de la NVRAM. \n \nCette bizarrerie tente de corriger les types de ces régions, par exemple ACPI NVS pour CSM ou MMIO pour MMIO. \n \nRemarque: la nécessité de cette bizarrerie est déterminée par les artefacts, les problèmes de veille et les échecs de démarrage. En général, seuls les très anciens firmwares ont besoin de cette bizarrerie.";

/* Class = "NSButtonCell"; title = "ForceExitBootServices"; ObjectID = "5sK-91-1dQ"; */
"5sK-91-1dQ.title" = "ForceExitBootServices";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "6o1-1f-ghJ"; */
"6o1-1f-ghJ.headerCell.title" = "Enabled";

/* Class = "NSTableColumn"; headerCell.title = "Find"; ObjectID = "7mi-i8-NsB"; */
"7mi-i8-NsB.headerCell.title" = "Find";

/* Class = "NSTableColumn"; headerCell.title = "Arch"; ObjectID = "82c-6J-7Bc"; */
"82c-6J-7Bc.headerCell.title" = "Arch";

/* Class = "NSButtonCell"; title = "SignalAppleOS"; ObjectID = "9fL-0g-rLi"; */
"9fL-0g-rLi.title" = "SignalAppleOS";

/* Class = "NSButtonCell"; title = "EnableSafeModeSlide"; ObjectID = "9lc-VM-DSq"; */
"9lc-VM-DSq.title" = "EnableSafeModeSlide";

/* Class = "NSButtonCell"; title = "ProtectUefiServices"; ObjectID = "9qv-tK-N7C"; */
"9qv-tK-N7C.title" = "ProtectUefiServices";

/* Class = "NSTableColumn"; headerCell.title = "Identifier"; ObjectID = "BvG-CB-C9w"; */
"BvG-CB-C9w.headerCell.title" = "Identifier";

/* Class = "NSTextFieldCell"; title = "ProvideMaxSlide"; ObjectID = "Dis-CN-0f1"; */
"Dis-CN-0f1.title" = "ProvideMaxSlide";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Reuse original hibernate memory map.\nThis option forces XNU kernel to ignore newly supplied memory map and assume that it did not change after waking from hibernation. This behaviour is required to work by Windows, which mandates to preserve runtime memory size and location after S4 wake.\nNote: This may be used to workaround buggy memory maps on older hardware, and is now considered rare legacy. Examples of such hardware are Ivy Bridge laptops with Insyde firmware, such as Acer V3-571G. Do not use this unless you fully understand the consequences."; ObjectID = "ELB-6s-GBW"; */
"ELB-6s-GBW.ibShadowedToolTip" = "Lorsque l'ordinateur sort de l'hibernation, les données du disque dur sont restaurées en mémoire, mais à ce stade, le noyau OC et le cache du noyau sont également écrits, ce qui peut provoquer des conflits. Cette option nous aide à résoudre ce problème Oui À l'heure actuelle, à l'exception de z370 / x299 / c422, il n'est pas possible d'hiberner (notez que le sommeil et l'hibernation sont deux concepts). Pour les ordinateurs de bureau, la fonction d'hibernation est encore plus inutile. Généralement, NO est sélectionné. \nLorsqu'elle est activée, la carte mémoire d'hibernation d'origine est réutilisée, uniquement requise par certains matériels plus anciens.";

/* Class = "NSButtonCell"; title = "DisableVariableWrite"; ObjectID = "FY9-MP-Vsp"; */
"FY9-MP-Vsp.title" = "DisableVariableWrite";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Generate Memory Map compatible with macOS.\n\nApple kernel has several limitations in parsing UEFI memory map:\n• Memory map size must not exceed 4096 bytes as Apple kernel maps it as a single 4K page. Since some firmwares have very large memory maps (approximately over 100 entries) Apple kernel will crash at boot.\n• Memory attributes table is ignored. EfiRuntimeServicesCode memory statically gets RX permissions, and all other memory types get RW permissions. Since some firmware drivers may write to global variables at runtime, Apple kernel will crash at calling UEFI runtime services, unless driver .data section has EfiRuntimeServicesData type. \n\nTo workaround these limitations this quirk applies memory attribute table permissions to the memory map passed to the Apple kernel and optionally attempts to unify contiguous slots of similar types if the resulting memory map exceeds 4 KB.\n\nNote 1: Since several types of firmware come with incorrect memory protection tables, this quirk often comes paired with SyncRuntimePermissions.\n\nNote 2 : The necessity of this quirk is determined by early boot failures. This quirk replaces EnableWriteUnprotector on firmware supporting Memory Attribute Tables (MAT). This quirk is usually unnecessary when using OpenDuetPkg, but may be required to boot macOS 10.6, and earlier, for reasons that are not clear."; ObjectID = "JMF-hg-GgC"; */
"JMF-hg-GgC.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false \nDescription: Générer une carte mémoire compatible avec macOS. \nLe noyau Apple a plusieurs limitations dans l'analyse de la carte mémoire UEFI: \n • La taille de la carte mémoire ne doit pas dépasser 4096 octets car le noyau Apple la mappe en un seul 4K page. Étant donné que certains firmwares ont de très grandes cartes mémoire (environ plus de 100 entrées), le noyau Apple se bloquera au démarrage. \n • La table des attributs de mémoire est ignorée. La mémoire EfiRuntimeServicesCode obtient statiquement les autorisations RX et tous les autres types de mémoire obtiennent les autorisations RW. Étant donné que certains pilotes de micrologiciel peuvent écrire dans des variables globales au moment de l'exécution, le noyau Apple se bloquera lors de l'appel des services d'exécution UEFI, sauf si la section .data du pilote a le type EfiRuntimeServicesData. \n \nPour contourner ces limitations, cette bizarrerie applique des autorisations de table d'attributs de mémoire au mappage de mémoire transmis au noyau Apple et tente éventuellement d'unifier les emplacements contigus de types similaires si le mappage de mémoire résultant dépasse 4 Ko. \n \nRemarque: La nécessité de cette bizarrerie est déterminé par les échecs de démarrage précoces. Cette bizarrerie remplace EnableWriteUnprotector sur la plupart des plateformes.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect from macOS NVRAM write access.\nThis is a security option allowing one to restrict NVRAM access in macOS. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\nNote: This quirk can also be used as an ugly workaround to buggy UEFI runtime services implementations that fail to write variables to NVRAM and break the rest of the operating system."; ObjectID = "KE8-rd-Ty5"; */
"KE8-rd-Ty5.ibShadowedToolTip" = "Les cartes mères NVRAM non natives doivent simuler nvram.plist et écrire des valeurs de variable, nous devons donc désactiver cette option pour empêcher d'autres programmes d'écrire dans nvram. Nous choisissons YES ici. Veuillez noter que si votre carte mère prend en charge le nvram natif (z370 / x299 / c422), veuillez sélectionner NON! \nLes cartes mères telles que Z390 / HM370 qui ne prennent pas en charge nativement macOS pour NVRAM doivent être activées.";

/* Class = "NSTabViewItem"; label = "Patch"; ObjectID = "N9f-29-rB5"; */
"N9f-29-rB5.label" = "Patch";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Remove runtime attribute from select MMIO regions.\nThis option reduces stolen memory footprint from the memory map by removing runtime bit for known memory regions. This quirk may result in the increase of KASLR slides available, but is not necessarily compatible with the target board without additional measures. In general this frees from 64 to 256 megabytes of memory (present in the debug log), and on some platforms it is the only way to boot macOS, which otherwise fails with allocation error at bootloader stage.\nThis option is generally useful on all  types of firmware except some very old ones such as Sandy Bridge. On some types of firmware, a list of addresses that need virtual addresses for proper NVRAM and hibernation\nfunctionality may be required. Use the MmioWhitelist section for this."; ObjectID = "NUB-EN-5ql"; */
"NUB-EN-5ql.ibShadowedToolTip" = "Les méthodes d'injection de mémoire incluent KASLR (injection distribuée dans chaque adresse mémoire) et la continuité. Lors de l'utilisation de KASLR, PCIE est chargé en mémoire, ce qui peut occuper toutes les valeurs disponibles et entraîner l'échec de l'injection du noyau OC et du cache du noyau, entraînant l'échec du démarrage. L'utilisation de la méthode KASLR est facile à commettre des erreurs. Nous sommes plus appropriés pour utiliser l'injection de mémoire continue et ajouter slide = 1 aux arguments de démarrage. Puisque nous ajouterons slide = 1 pour utiliser l'injection de mémoire continue, cette option est généralement sélectionnée NON.";

/* Class = "NSBox"; title = "Quirks"; ObjectID = "PeB-9S-Amz"; */
"PeB-9S-Amz.title" = "Quirks";

/* Class = "NSButtonCell"; title = "RebuildAppleMemoryMap"; ObjectID = "Qht-28-YA5"; */
"Qht-28-YA5.title" = "RebuildAppleMemoryMap";

/* Class = "NSScrollView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Exceptional MMIO address, which memory descriptor should be left virtualised (unchanged) by DevirtualiseMmio. This means that the firmware will be able to directly communicate with this memory region during operating system functioning, because the region this value is in will be assigned a virtual address.\nThe addresses written here must be part of the memory map, have EfiMemoryMappedIO type and EFI_MEMORY_RUNTIME attribute (highest bit) set. To find the list of the candidates the debug log can be used.\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This address will be devirtualised unless set to true."; ObjectID = "RWw-Gp-0A4"; */
"RWw-Gp-0A4.ibShadowedToolTip" = "Par défaut, le premier élément est un correctif d'adressage de la mémoire pour les puces Haswell. Si ces puces rencontrent des problèmes liés à la mémoire, veuillez l'activer (activer la sélection oui). \nLe deuxième élément par défaut est la configuration PCI de la carte de démarrage ici. Lorsque les périphériques ACPI et PCI sont libérés en même temps, l'adresse mémoire 0x1000 est occupée et bloquée dans la configuration PCI. Si vous rencontrez de tels problèmes, veuillez l'ouvrir.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false \nDescription: Report macOS being loaded through OS Info for any OS. \n\nThis quirk is useful on Mac firmwares, which behaves differently in different OS. For example, it is supposed to enable Intel GPU in Windows and Linux in some dual-GPU MacBook models."; ObjectID = "Ryj-m2-2MI"; */
"Ryj-m2-2MI.ibShadowedToolTip" = "Signale macOS pour tout système d'exploitation chargé via OS Info. \ Le micrologiciel du système d'exploitation NMac a un comportement différent sur différents systèmes d'exploitation, cette fonctionnalité est donc très utile. Par exemple, les GPU Intel doivent être activés sous Windows et Linux sur certains modèles de MacBook à double GPU. \ Généralement non utilisé, choisissez NON";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Disable single user mode.\nThis is a security option allowing one to restrict single user mode usage by ignoring CMD+S hotkey and -s boot argument. The behaviour with this quirk enabled is supposed to match T2-based model behaviour. Read this article to understand how to use single user mode with this quirk enabled."; ObjectID = "Ssn-0z-qIb"; */
"Ssn-0z-qIb.ibShadowedToolTip" = "Il s'agit de savoir si l'hôte peut activer le mode mono-utilisateur. Une fois allumé, l'utilisation de Cmd + S et -s sera interdite, ce qui rapprochera l'appareil de la pomme blanche T2. Si vous le jugez utile, allumez-le et choisissez généralement NON.";

/* Class = "NSButtonCell"; title = "ProtectMemoryRegions"; ObjectID = "USC-aA-F2K"; */
"USC-aA-F2K.title" = "ProtectMemoryRegions";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean \nFailsafe: false\nDescription: Protect UEFI Secure Boot variables from being written.\nReports security violation during attempts to write to db, dbx, PK, and KEK variables from the operating system.\n\nNote: This quirk mainly attempts to avoid issues with NVRAM implementations with problematic defragmentation, such as select Insyde or MacPro5,1."; ObjectID = "VnZ-XI-LOq"; */
"VnZ-XI-LOq.ibShadowedToolTip" = "Protéger les variables de démarrage sécurisé UEFI contre l'écriture. \nSignaler un conflit de sécurité survenu lors d'une tentative d'écriture dans les variables db, dbx, PK et KEK à partir du système d'exploitation. \n \nRemarque: cette bizarrerie essaie principalement d'éviter l'impact des problèmes de défragmentation sur la mise en œuvre de la NVRAM, tels que le choix d'Insyde ou de MacPro5,1.";

/* Class = "NSTableColumn"; headerCell.title = "Address*"; ObjectID = "XBA-aR-mC0"; */
"XBA-aR-mC0.headerCell.title" = "Addresse*";

/* Class = "NSButtonCell"; title = "SyncRuntimePermissions"; ObjectID = "XIy-K6-Der"; */
"XIy-K6-Der.title" = "SyncRuntimePermissions";

/* Class = "NSButtonCell"; title = "EnableWriteUnprotector"; ObjectID = "XaK-gI-0aI"; */
"XaK-gI-0aI.title" = "EnableWriteUnprotector";

/* Class = "NSButtonCell"; title = "ProvideCustomSlide"; ObjectID = "a8S-kc-6sK"; */
"a8S-kc-6sK.title" = "ProvideCustomSlide";

/* Class = "NSButtonCell"; title = "DisableSingleUser"; ObjectID = "bMR-Kw-wwp"; */
"bMR-Kw-wwp.title" = "DisableSingleUser";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Allows booting macOS through a relocation block.\n\nRelocation block is a scratch buffer allocated in lower 4 GB to be used for loading the kernel and related structures by EfiBoot on firmwares where lower memory is otherwise occupied by the (assumed to be) non-runtime data.\nRight before kernel startup the relocation block is copied back to lower addresses. Similarly all the other addresses pointing to relocation block are also carefully adjusted. Relocation block can be used when:\n• No better slide exists (all the memory is used)\n• slide=0 is forced (by an argument or safe mode)\n• KASLR (slide) is unsupported (this is macOS 10.7 or older)\n\nThis quirk requires ProvideCustomSlide to also be enabled and generally needs AvoidRuntimeDefrag to work correctly. Hibernation is not supported when booting with a relocation block (but relocation block is not always used when the quirk is enabled).\n\nNote: While this quirk is required to run older macOS versions on platforms with used lower memory it is not compatible with some hardware and macOS 11. In this case you may try to use EnableSafeModeSlide instead."; ObjectID = "bib-aL-YwI"; */
"bib-aL-YwI.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Allows booting macOS through a relocation block.\n\nRelocation block is a scratch buffer allocated in lower 4 GB to be used for loading the kernel and related structures by EfiBoot on firmwares where lower memory is otherwise occupied by the (assumed to be) non-runtime data.\nRight before kernel startup the relocation block is copied back to lower addresses. Similarly all the other addresses pointing to relocation block are also carefully adjusted. Relocation block can be used when:\n• No better slide exists (all the memory is used)\n• slide=0 is forced (by an argument or safe mode)\n• KASLR (slide) is unsupported (this is macOS 10.7 or older)\n\nThis quirk requires ProvideCustomSlide to also be enabled and generally needs AvoidRuntimeDefrag to work correctly. Hibernation is not supported when booting with a relocation block (but relocation block is not always used when the quirk is enabled).\n\nNote: While this quirk is required to run older macOS versions on platforms with used lower memory it is not compatible with some hardware and macOS 11. In this case you may try to use EnableSafeModeSlide instead.";

/* Class = "NSTableColumn"; headerCell.title = "Enabled"; ObjectID = "c3O-jR-hal"; */
"c3O-jR-hal.headerCell.title" = "Activer";

/* Class = "NSTableColumn"; headerCell.title = "Count"; ObjectID = "cCx-7g-cuM"; */
"cCx-7g-cuM.headerCell.title" = "Count";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Retry ExitBootServices with new memory map on failure.\nTry to ensure that ExitBootServices call succeeds even with outdated MemoryMap key argument by obtaining current memory map and retrying ExitBootServices call.\nNote: The necessity of this quirk is determined by early boot crashes of the firmware. Do not use this without a full understanding of the consequences."; ObjectID = "cTN-CD-c3M"; */
"cTN-CD-c3M.ibShadowedToolTip" = "Cette option permet à ces très anciennes cartes mères d'utiliser également l'adressage mémoire. Normalement, sélectionnez NON.";

/* Class = "NSTableColumn"; headerCell.title = "Skip"; ObjectID = "dwb-DP-v4I"; */
"dwb-DP-v4I.headerCell.title" = "Skip";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "f4e-pW-Orc"; */
"f4e-pW-Orc.headerCell.title" = "Comment";

/* Class = "NSTextField"; ibShadowedToolTip = "Type: plist integer\nFailsafe: 0\nDescription: Provide maximum KASLR slide when higher ones are unavailable.\n\nThis option overrides the maximum slide instead of TOTAL_SLIDE_NUM (256) when ProvideCustomSlide is enabled. It is believed that modern firmware allocates pool memory from top to bottom, effectively resulting in free memory when slide scanning is used later as temporary memory during kernel loading. When such memory is not available, this option can stop the evaluation of higher slides.\n\nNote: The necessity of this quirk is determined by random boot failure when ProvideCustomSlide is enabled  and the randomized slide fall into the unavailable range. When AppleDebug is enabled, usually the debug log may contain messages such as AAPL: [EB|‘LD:LKC] } Err(0x9). To find the optimal value, manually append slide=X to boot-args and log the largest one that will not result in boot failures."; ObjectID = "gi2-WY-dKJ"; */
"gi2-WY-dKJ.ibShadowedToolTip" = "Type: plist integer\nFailsafe: 0\nDescription: Provide maximum KASLR slide when higher ones are unavailable.\nThis option overrides the maximum slide instead of TOTAL_SLIDE_NUM (256) when ProvideCustomSlide is enabled. It is believed that modern firmwares allocate pool memory from top to bottom, effectively resulting in free memory at the time of slide scanning being later used as temporary memory during kernel loading. In case those memory are unavailable, this option can stop evaluating higher slides.\n\nNote: The necessity of this quirk is determined by random boot failure when ProvideCustomSlide is enabled  and the randomized slide fall into the unavailable range. When AppleDebug is enabled, usually the debug log may contain messages like AAPL: [EB|‘LD:LKC] } Err(0x9). To find the optimal value, manually append slide=X to boot-args and log the largest one that won’t cause boot failure.";

/* Class = "NSButtonCell"; title = "EnableForAll"; ObjectID = "hF2-W3-w6Y"; */
"hF2-W3-w6Y.title" = "Activer pour tous";

/* Class = "NSTableColumn"; headerCell.title = "ReplaceMask"; ObjectID = "jK8-UP-6rI"; */
"jK8-UP-6rI.headerCell.title" = "ReplaceMask";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Setup virtual memory at SetVirtualAddresses.\n\nSome types of firmware access memory by virtual addresses after a SetVirtualAddresses call, resulting in early boot crashes. This quirk workarounds the problem by performing early boot identity mapping of assigned virtual addresses to physical memory.\n\nNote: The necessity of this quirk is determined by early boot failures. Currently, new firmware with memory protection support (such as OVMF) do not support this quirk."; ObjectID = "l3S-mh-5k0"; */
"l3S-mh-5k0.ibShadowedToolTip" = "Indique s'il faut établir une mémoire virtuelle et mapper la mémoire physique. Lorsque nous démarrons, le programme OC a besoin d'une mémoire continue pour stocker le noyau et d'autres choses, et la mémoire physique réelle est généralement dispersée. Par conséquent, nous utilisons la mémoire virtuelle pour créer une mémoire contiguë pour une utilisation OC et la mapper dans la mémoire physique décentralisée. Généralement, nous choisissons OUI.";

/* Class = "NSTabViewItem"; label = "MmioWhitelist"; ObjectID = "mrQ-IT-UQ3"; */
"mrQ-IT-UQ3.label" = "MmioWhitelist mémoire mappée liste blanche IO";

/* Class = "NSTableColumn"; headerCell.title = "Replace"; ObjectID = "mtD-yq-Tub"; */
"mtD-yq-Tub.headerCell.title" = "Replace";

/* Class = "NSTableColumn"; headerCell.title = "Comment"; ObjectID = "ndf-NP-2rM"; */
"ndf-NP-2rM.headerCell.title" = "Commentaire";

/* Class = "NSButtonCell"; title = "AllowRelocationBlock"; ObjectID = "oFh-ac-Blm"; */
"oFh-ac-Blm.title" = "AllowRelocationBlock";

/* Class = "NSTableView"; ibShadowedToolTip = "1. Arch\nType: plist string\nFailsafe: Any\nDescription: Booter patch architecture (Any, i386, x86_64).\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Count\nType: plist integer\nFailsafe: 0\nDescription: Number of patch occurrences to apply. 0 applies the patch to all occurrences found.\n4. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This booter patch will not be used unless set to true.\n5. Find\nType: plist data\nFailsafe: Empty data\nDescription: Data to find. This must equal to Replace in size.\n6. Identifier\nType: plist string\nFailsafe: Empty string\nDescription: Apple for macOS booter (generally boot.efi); or a name with suffix (e.g. bootmgfw.efi) for a specific booter; or Any / empty string (failsafe) to match any booter.\n7. Limit\nType: plist integer\nFailsafe: 0\nDescription: Maximum number of bytes to search for. Can be set to 0 to look through the whole booter.\n8. Mask\nType: plist data\nFailsafe: Empty data\nDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Can be set to empty data to be ignored. Must equal to Find in size otherwise.\n9. Replace\nType: plist data\nFailsafe: Empty data\nDescription: Replacement data of one or more bytes.\n10. ReplaceMask\nType: plist data\nFailsafe: Empty data\nDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise.\n11. Skip\nType: plist integer\nFailsafe: 0\nDescription: Number of found occurrences to be skipped before replacement is done."; ObjectID = "oWj-qp-bH5"; */
"oWj-qp-bH5.ibShadowedToolTip" = "1. Arch\nType: plist string\nFailsafe: Any\nDescription: Booter patch architecture (Any, i386, x86_64).\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Count\nType: plist integer\nFailsafe: 0\nDescription: Number of patch occurrences to apply. 0 applies the patch to all occurrences found.\n4. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This booter patch will not be used unless set to true.\n5. Find\nType: plist data\nFailsafe: Empty data\nDescription: Data to find. This must equal to Replace in size.\n6. Identifier\nType: plist string\nFailsafe: Empty string\nDescription: Apple for macOS booter (generally boot.efi); or a name with suffix (e.g. bootmgfw.efi) for a specific booter; or Any / empty string (failsafe) to match any booter.\n7. Limit\nType: plist integer\nFailsafe: 0\nDescription: Maximum number of bytes to search for. Can be set to 0 to look through the whole booter.\n8. Mask\nType: plist data\nFailsafe: Empty data\nDescription: Data bitwise mask used during find comparison. Allows fuzzy search by ignoring not masked (set to zero) bits. Can be set to empty data to be ignored. Must equal to Find in size otherwise.\n9. Replace\nType: plist data\nFailsafe: Empty data\nDescription: Replacement data of one or more bytes.\n10. ReplaceMask\nType: plist data\nFailsafe: Empty data\nDescription: Data bitwise mask used during replacement. Allows fuzzy replacement by updating masked (set to non-zero) bits. Can be set to empty data to be ignored. Must equal to Replace in size otherwise.\n11. Skip\nType: plist integer\nFailsafe: 0\nDescription: Number of found occurrences to be skipped before replacement is done.";

/* Class = "NSButtonCell"; title = "DevirtualiseMmio"; ObjectID = "pkh-Nr-Lgr"; */
"pkh-Nr-Lgr.title" = "DevirtualiseMmio";

/* Class = "NSButtonCell"; title = "AvoidRuntimeDefrag"; ObjectID = "quR-9w-VV5"; */
"quR-9w-VV5.title" = "AvoidRuntimeDefrag";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Patch bootloader to have KASLR enabled in safe mode.\nThis option is relevant to the users that have issues booting to safe mode (e.g. by holding shift or using -x boot argument). By default safe mode forces 0 slide as if the system was launched with slide=0 boot argument. This quirk tries to patch boot.efi to lift that limitation and let some other value (from 1 to 255) be used. This quirk requires ProvideCustomSlide to be enabled.\nNote: The necessity of this quirk is determined by safe mode availability. If booting to safe mode fails, this option can be tried to be enabled."; ObjectID = "qyH-8f-uTZ"; */
"qyH-8f-uTZ.ibShadowedToolTip" = "Lorsqu'il est activé, permet aux valeurs de diapositive d'être utilisées en mode sans échec. Ce n'est pas si important, vous n'entrerez pas en mode sans échec tous les jours. Comme le z390, qui n'utilise pas la méthode d'injection de mémoire distribuée (KASLR), choisissez OUI, ce qui correspond à la situation normale.";/* Class = "NSScrollView"; ibShadowedToolTip = "1. Address\nType: plist integer\nFailsafe: 0\nDescription: Exceptional MMIO address, which memory descriptor should be left virtualised (unchanged) by DevirtualiseMmio. This means that the firmware will be able to directly communicate with this memory region during operating system functioning, because the region this value is in will be assigned a virtual address.\nThe addresses written here must be part of the memory map, have EfiMemoryMappedIO type and EFI_MEMORY_RUNTIME attribute (highest bit) set. To find the list of the candidates the debug log can be used.\n2. Comment\nType: plist string\nFailsafe: Empty string\nDescription: Arbitrary ASCII string used to provide human readable reference for the entry. It is implementation defined whether this value is used.\n3. Enabled\nType: plist boolean\nFailsafe: false\nDescription: This address will be devirtualised unless set to true."; ObjectID = "RWw-Gp-0A4"; */

/* Class = "NSButtonCell"; title = "ProtectSecureBoot"; ObjectID = "rWG-6j-Mxs"; */
"rWG-6j-Mxs.title" = "ProtectSecureBoot";

/* Class = "NSButtonCell"; title = "ForceBooterSignature"; ObjectID = "sHw-qr-Pag"; */
"sHw-qr-Pag.title" = "ForceBooterSignature";

/* Class = "NSButtonCell"; title = "SetupVirtualMap"; ObjectID = "sNx-S4-Yhl"; */
"sNx-S4-Yhl.title" = "SetupVirtualMap";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Protect from boot.efi runtime memory defragmentation.\nThis option fixes UEFI runtime services (date, time, NVRAM, power control, etc.) support on firmware that uses SMM backing for select services such as variable storage. SMM may try to access physical addresses, but they get moved by boot.efi.\n\nNote: Most types of firmware, apart from Apple and VMware, need this quirk."; ObjectID = "ubm-2i-zPE"; */
"ubm-2i-zPE.ibShadowedToolTip" = "La plupart des UEFI écriront l'heure, la gestion de l'alimentation et d'autres informations.Toutes les cartes mères Apple noires devraient choisir OUI.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Provide custom KASLR slide on low memory.\nThis option performs memory map analysis of the firmware and checks whether all slides (from 1 to 255) can be used. As boot.efi generates this value randomly with rdrand or pseudo randomly rdtsc, there is a chance of boot failure when it chooses a conflicting slide. In case potential conflicts exist, this option forces macOS to use a pseudo random value among the available ones. This also ensures that slide= argument is never passed to the operating system for security reasons.\nNote: The necessity of this quirk is determined by OCABC: Only N/256 slide values are usable! message in the debug log. If the message is present, this option is to be enabled."; ObjectID = "wGH-hP-xhD"; */
"wGH-hP-xhD.ibShadowedToolTip" = "Indique s'il faut utiliser les valeurs des diapositives. Choisissez généralement une injection continue dans la mémoire et coopérez avec la diapositive, choisissez donc OUI. \nBat.bat a expliqué: \nS'il y a un conflit dans les valeurs Slide, cette option force macOS à effectuer les opérations suivantes: \nUtilisez une valeur pseudo-aléatoire. Requis uniquement si vous rencontrez Seules les valeurs de diapositives N / 256 sont utilisables!";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Set macOS boot-signature to OpenCore launcher.\n\nBooter signature, essentially a SHA-1 hash of the loaded image, is used by Mac EFI to verify the authenticity of the bootloader when waking from hibernation. This option forces macOS to use OpenCore launcher SHA-1 hash as a booter signature to let OpenCore shim hibernation wake on Mac EFI firmware.\n\nNote: OpenCore launcher path is determined from LauncherPath property."; ObjectID = "woE-nK-MFN"; */
"woE-nK-MFN.ibShadowedToolTip" = "Type: plist boolean\nFailsafe: false\nDescription: Set macOS boot-signature to OpenCore launcher.\n\nBooter signature, essentially a SHA-1 hash of the loaded image, is used by Mac EFI to verify the authenticity of the bootloader when waking from hibernation. This option forces macOS to use OpenCore launcher SHA-1 hash as a booter signature to let OpenCore shim hibernation wake on Mac EFI firmware.\n\nNote: OpenCore launcher path is determined from LauncherPath property.";

/* Class = "NSTableColumn"; headerCell.title = "Limit"; ObjectID = "xEr-hF-nBr"; */
"xEr-hF-nBr.headerCell.title" = "Limit";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Permit write access to UEFI runtime services code.\nThis option bypasses RˆX permissions in code pages of UEFI runtime services by removing write protection (WP) bit from CR0 register during their execution. This quirk requires OC_FIRMWARE_RUNTIME protocol implemented in OpenRuntime.efi.\nNote: This quirk may potentially weaken firmware security, please use RebuildAppleMemoryMap if the firmware supports memory attributes table (MAT). Refer to OCABC: MAT support is 1/0 log entry to determine whether\nMAT is supported."; ObjectID = "xH6-La-kRg"; */
"xH6-La-kRg.ibShadowedToolTip" = "Pour vous assurer que nvram peut écrire normalement sans être affecté par certains services dans UEFI, sélectionnez OUI, quelle que soit la carte mère.";

/* Class = "NSButton"; ibShadowedToolTip = "Type: plist boolean\nFailsafe: false\nDescription: Update memory permissions for OpenRuntime to function. \n\nSome types of firmware fail to properly handle runtime permissions:\n• They incorrectly mark OpenRuntime as not executable in the memory map.\n• They incorrectly mark OpenRuntime as not executable in the memory attributes table.\n• They lose entries from the memory attributes table after OpenRuntime is loaded.\n• They mark items in the memory attributes table as read-write-execute.\n\nThis quirk tries to update memory map and memory attributes table to correct this.\n\nNote: The need for this quirk is indicated by early boot failures . Only firmware released after 2017 is typically affected."; ObjectID = "ymv-yt-Lvn"; */
"ymv-yt-Lvn.ibShadowedToolTip" = "Type: plist boolean \nFailsafe: false \nDescription: Mettez à jour les autorisations de mémoire pour qu'OpenRuntime fonctionne. \n \nCertains firmwares peuvent marquer incorrectement OpenRuntime comme non exécutable, ce quirks met à jour la carte mémoire et le tableau des attributs de mémoire pour corriger cela. \n \nRemarque: La nécessité de ce quirk est déterminée par les échecs de démarrage précoces sous macOS ou sous Linux / Windows . En général, seuls les firmwares lancés en 2018 ou après sont affectés.";
